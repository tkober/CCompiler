%{

#include <stdio.h>

#import "CCParser.h"
#import "CCScanner.h"
#import "CCSymbolTable.h"
#import "CCAbstractSyntaxTree.h"


id<CCOutput> _output;

%}

%union {
    struct CCAbstractSyntaxTree *ast;
    double number;
}


%type <ast> expr 
%type <ast> factor 
%type <ast> term


// Identifier
%token <number> NUMBER
%token VARIABLE

// Operators
%token ADD 
%token SUB 
%token MUL 
%token DIV 
%token ABSOLUTE

// Braces
%token OB 
%token CB

// File
%token EOL


%%


arithmetic_expression: /* nothing */
//| arithmetic_expression expr EOL { [_output printResult:[NSString stringWithFormat:@"[Line %i] valid\n", yylineno]]; }
| arithmetic_expression expr EOL { 
    [_output printResult:[NSString stringWithFormat:@"%4.4g\n", evaluateAST($2)]]; 
    freeAST($2);
    [_output printResult:@"> "];
}

| arithmetic_expression EOL { [_output printResult:@"> "] }
;

expr: factor
| expr ADD factor   { $$ = newAST('+', $1, $3); }
| expr SUB factor   { $$ = newAST('-', $1, $3); }
;

factor: term
| factor MUL term   { $$ = newAST('*', $1, $3); }
| factor DIV term   { $$ = newAST('/', $1, $3); }
;

term: NUMBER        { $$ = newNumberNode($1); }
//| VARIABLE
| ABSOLUTE term     { $$ = newAST('|', $2, NULL ); }
| OB expr CB        { $$ = $2; }
;


%%


void start_scanning(const char *input, id<CCOutput> output)
{
    yylineno = 0;
    _output = output;
    YY_BUFFER_STATE buffer=yy_scan_string(input);
    yyparse();
    [[CCSymbolTable sharedInstance] printSymbolTable:output];
    yy_delete_buffer(buffer);
}


int yyerror(char *s)
{
    [_output printError:[NSString stringWithFormat:@"error: %s\n", s]];
    return 0;
}